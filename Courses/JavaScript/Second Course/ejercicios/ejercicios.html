<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ejercicios de Programación en JS</title>
</head>
<body>

    <script>

        /*
            1) Programa una función que cuente el número de caracteres de una cadena de texto, pe. 
            miFuncion("Hola Mundo") devolverá 10.

            2) Programa una función que te devuelva el texto recortado según el número de caracteres 
            indicados, pe. miFuncion("Hola Mundo", 4) devolverá "Hola".

            3) Programa una función que dada una String te devuelva un Array de textos separados por 
            cierto caracter,pe. miFuncion('hola que tal', ' ') devolverá ['hola', 'que', 'tal'].

            4) Programa una función que repita un texto X veces, pe. miFuncion('Hola Mundo', 3) 
            devolverá Hola Mundo Hola Mundo Hola Mundo.

            5) Programa una función que invierta las palabras de una cadena de texto, 
            pe. miFuncion("Hola Mundo") devolverá "odnuM aloH".

            6) Programa una función para contar el número de veces que se repite una palabra en un 
            texto largo, pe. miFuncion("hola mundo adios mundo", "mundo") devolverá 2.

            7) Programa una función que valide si una palabra o frase dada, es un palíndromo 
            (que se lee igual en un sentido que en otro), pe. mifuncion("Salas") devolverá true.

            8) Programa una función que elimine cierto patrón de caracteres de un texto dado, 
            pe. miFuncion("xyz1, xyz2, xyz3, xyz4 y xyz5", "xyz") devolverá  "1, 2, 3, 4 y 5.

            9) Programa una función que obtenga un numero aleatorio entre 501 y 600.

            10) Programa una función que reciba un número y evalúe si es capicúa o no 
            (que se lee igual en un sentido que en otro), pe. miFuncion(2002) devolverá true.

            11) Programa una función que calcule el factorial de un número (El factorial de un 
            entero positivo n, se define como el producto de todos los números enteros positivos 
            desde 1 hasta n), pe. miFuncion(5) devolverá 120.

            12) Programa una función que determine si un número es primo (aquel que solo es 
            divisible por sí mismo y 1) o no, pe. miFuncion(7) devolverá true.

            13) Programa una función que determine si un número es par o impar, 
            pe. miFuncion(29) devolverá Impar.

            14) Programa una función para convertir grados Celsius a Fahrenheit y viceversa, 
            pe. miFuncion(0,"C") devolverá 32°F.

            15) Programa una función para convertir números de base binaria a decimal y viceversa, 
            pe. miFuncion(100,2) devolverá 4 base 10.

            16) Programa una función que devuelva el monto final después de aplicar un descuento a 
            una cantidad dada, pe. miFuncion(1000, 20) devolverá 800.

            17) Programa una función que dada una fecha válida determine cuantos años han pasado 
            hasta el día de hoy, pe. miFuncion(new Date(1984,4,23)) devolverá 35 años (en 2020).

            18) Programa una función que dada una cadena de texto cuente el número de vocales y 
            consonantes, pe. miFuncion("Hola Mundo") devuelva Vocales: 4, Consonantes: 5.

            19) Programa una función que valide que un texto sea un nombre válido, 
            pe. miFuncion("Jonathan MirCha") devolverá verdadero.

            20) Programa una función que valide que un texto sea un email válido, 
            pe. miFuncion("jonmircha@gmail.com") devolverá verdadero.

            21) Programa una función que dado un array numérico devuelve otro array con los números 
            elevados al cuadrado, pe. mi_funcion([1, 4, 5]) devolverá [1, 16, 25].

            22) Programa una función que dado un array devuelva el número mas alto y el más bajo de 
            dicho array, pe. miFuncion([1, 4, 5, 99, -60]) devolverá [99, -60].

            23) Programa una función que dado un array de números devuelva un objeto con 2 arreglos 
            en el primero almacena los números pares y en el segundo los impares, 
            pe. miFuncion([1,2,3,4,5,6,7,8,9,0]) devolverá {pares: [2,4,6,8,0], impares: [1,3,5,7,9]}.

            24) Programa una función que dado un arreglo de números devuelva un objeto con dos arreglos, 
            el primero tendrá los numeros ordenados en forma ascendente y el segundo de forma descendiente, 
            pe. miFuncion([7, 5,7,8,6]) devolverá { asc: [5,6,7,7,8], desc: [8,7,7,6,5] }.
            
            25) Programa una función que dado un arreglo de elementos, elimine los duplicados, 
            pe. miFuncion(["x", 10, "x", 2, "10", 10, true, true]) devolverá ["x", 10, 2, "10", true].
            
            26) Programa una función que dado un arreglo de números obtenga el promedio, 
            pe. promedio([9,8,7,6,5,4,3,2,1,0]) devolverá 4.5.

            27) Programa una clase llamada Pelicula.

            La clase recibirá un objeto al momento de instanciarse con los siguentes datos: id de la 
            película en IMDB, titulo, director, año de estreno, país o países de origen, géneros y calificación en IMBD.
            - Todos los datos del objeto son obligatorios.
            - Valida que el id IMDB tenga 9 caracteres, los primeros 2 sean letras y los 
                7 restantes números.
            - Valida que el título no rebase los 100 caracteres.
            - Valida que el director no rebase los 50 caracteres.
            - Valida que el año de estreno sea un número entero de 4 dígitos.
            - Valida que el país o paises sea introducidos en forma de arreglo.
            - Valida que los géneros sean introducidos en forma de arreglo.
            - Valida que los géneros introducidos esten dentro de los géneros 
                aceptados*.
            - Crea un método estático que devuelva los géneros aceptados*.
            - Valida que la calificación sea un número entre 0 y 10 pudiendo ser 
                decimal de una posición.
            - Crea un método que devuelva toda la ficha técnica de la película.
            - Apartir de un arreglo con la información de 3 películas genera 3 
                instancias de la clase de forma automatizada e imprime la ficha técnica 
                de cada película.

            * Géneros Aceptados: Action, Adult, Adventure, Animation, Biography, Comedy, Crime, Documentary ,Drama, Family, 
            Fantasy, Film Noir, Game-Show, History, Horror, Musical, Music, Mystery, News, Reality-TV, Romance, Sci-Fi, 
            Short, Sport, Talk-Show, Thriller, War, Western.
                
        */

        //EJERCICIO 1
        //1) Programa una función que cuente el número de caracteres de una cadena de texto, pe. miFuncion("Hola Mundo") devolverá 10.

        //Como es una función declarada, hace efecto el hoisting y puedo llamar
        //a las funciones antes de que declararlas

        /*
        contarCaracteres()
        contarCaracteres("Hola probando ejercicio")

        function contarCaracteres(cadena =""){
            if(!cadena){
                console.warn("No ingresaste ninguna cadena")
            }else{
                console.info(`La cadena "${cadena}" tiene ${cadena.length} caracteres`)
            }
        }
        */

        //Hacemos lo mismo pero con las Arrow Function
        //Aquí llamamos a las funciones después de declararlas porque no usan hoisting
        
        /*
        const contarCaracteres = (cadena ="") => 
            (!cadena) 
                ? console.warn("No ingresaste ninguna cadena") 
                : console.info(`La cadena "${cadena}" tiene ${cadena.length} caracteres`)
       
        contarCaracteres()
        contarCaracteres("Hola probando ejercicio")
        */









        //EJERCICIO 2
        //2) Programa una función que te devuelva el texto recortado según el 
        //número de caracteres indicados, pe. miFuncion("Hola Mundo", 4) devolverá "Hola".

        //Para JS todo esto es una línea de código porque estamos usando el return implícito de los arrow functions
        //Este tipo de estructuras programando son muy frecuentes en ANGULAR, REACT y VUE.
        /*
        const recortarTexto = (cadena="",longitud=undefined) =>
            (!cadena)
                ? console.warn("No ingresaste una cadena de texto")
                : (longitud === undefined)
                    ? console.warn("No ingresaste la longitud para recortar el texto")
                    : console.info(cadena.slice(0,longitud))

        recortarTexto()
        recortarTexto("Hola esto es una prueba")
        recortarTexto("",5)
        recortarTexto("Hola esto es una prueba",4)
        */










        //EJERCICIO 3
        //3) Programa una función que dada una String te devuelva un Array de textos separados por 
        //cierto caracter, pe. miFuncion('hola que tal', ' ') devolverá ['hola', 'que', 'tal'].
        /*
        const cadenaAArreglo = (cadena = "",separador = undefined) =>
            (!cadena)
                ? console.warn("No ingresaste una cadena de texto")
                : (separador === undefined)
                    ? console.warn("No ingresaste el caracter separador")
                    : console.info(cadena.split(separador))
                    
        cadenaAArreglo()
        cadenaAArreglo("","-")
        cadenaAArreglo("Esto es una prueba de una cadena")
        cadenaAArreglo("Esto es una prueba de una cadena", " ")
        */

        
        
        


        
        
        
        
        
        
        
        //EJERCICIO 4
        //4) Programa una función que repita un texto X veces, 
        //pe. miFuncion('Hola Mundo', 3) devolverá Hola Mundo Hola Mundo Hola Mundo.

        //Los frameworks/librerías ANGULAR y REACT ya tienen paquetes que se encargan de realizar estas validaciones
        //Como vamos a tener + de una línea de código vamos a usar llaves, el return (porque no lo tenemos implícito) y los if/else
        /*
        const repetirTexto = (texto = "", veces = undefined) => {
            if(!texto) return console.warn("No ingresaste un texto")
            if (veces === undefined) return console.warn("No ingresaste el número de veces a repetir el texto")
            if (veces === 0) return console.error("El número de veces no puede ser 0")
            if (Math.sign(veces) === -1) return console.error("El número de veces no puede ser negativo")
        
            for (let i = 0; i < veces; i++) console.info(`${texto},${i+1}`)
            
        }

        repetirTexto("",2)
        repetirTexto("Hola esto es una prueba")
        repetirTexto("Hola esto es una prueba",0)
        repetirTexto("Hola esto es una prueba",-2)
        repetirTexto("Hola esto es una prueba",3)
        */










        //EJERCICIO 5
        //5) Programa una función que invierta las palabras de una cadena de texto, 
        //pe. miFuncion("Hola Mundo") devolverá "odnuM aloH".
        /*
        const invertirCadena = (cadena = "") =>
            (!cadena)
                ? console.warn("No ingresaste una cadena de texto")
                //para transformar un arreglo en una cadena de texto usamos join
                : console.info(cadena.split("").reverse().join(""))

        invertirCadena()
        invertirCadena("Hola esto es una prueba")
        */










        //EJERCICIO 6
        //6) Programa una función para contar el número de veces que se repite una palabra 
        //en un texto largo, pe. miFuncion("hola mundo adios mundo", "mundo") devolverá 2.

        /*
        const textoEnCadena = (cadena ="", texto = "") => {
            if (!cadena) return console.warn("No ingresaste el texto")
            if (!texto) return console.warn ("No ingresaste la palabra a evaluar")

            let i = 0,
                contador = 0

            while (i != -1){
                i = cadena.indexOf(texto,i)
                if(i !== -1){
                    i++
                    contador++
                }
            }
            return console.info(`La palabra ${texto} se repite ${contador} veces`)
        }

        textoEnCadena()
        textoEnCadena("Esto es una es prueba es una prueba es")
        textoEnCadena("Esto es una es prueba es una prueba es", "es")
        */












        //EJERCICIO 7
        //7) Programa una función que valide si una palabra o frase dada, es un 
        //palíndromo (que se lee igual en un sentido que en otro), pe. mifuncion("Salas") devolverá true.

        /*
        const palindromo = (palabra = "") => {
            if (!palabra) return console.warn("No ingresaste una palabra o frase")
            
            palabra = palabra.toLocaleLowerCase()
            let alReves = palabra.split("").reverse().join("")
            
            return (palabra === alReves)
                ? console.info(`SI es palíndromo. Palabra original ${palabra}. Palabra al revés ${alReves}`)
                : console.info(`NO es palíndromo. Palabra original ${palabra}. Palabra al revés ${alReves}`)

        }

        palindromo()
        palindromo("hola")
        palindromo("SaLas")
        */










        //EJERCICIO 8
        //8) Programa una función que elimine cierto patrón de caracteres de un texto dado, 
        //pe. miFuncion("xyz1, xyz2, xyz3, xyz4 y xyz5", "xyz") devolverá  "1, 2, 3, 4 y 5.

        /*
        const eliminarCacacteres = (texto = "", patron = "") =>
            (!texto)
                ? console.warn("No ingresaste un texto")
                : (!patron)
                    ? console.warn("No ingresaste un patron")
                    :console.info(texto.replace(new RegExp(patron,"ig"),""))


        eliminarCacacteres()
        eliminarCacacteres("xyz1, xyz2, xyz3, xyz4 y xyz5")
        eliminarCacacteres("xyz1, xyz2, xyz3, xyz4 y xyz5", "xyz")
        eliminarCacacteres("Esto es  una prueba para eliminar la letra 'a'","a")
        eliminarCacacteres("Esto es 123 una 122 prueba 12 para 123 eliminar 12 la letra letras","[a-z]")
        */










        //EJERCICIO 9
        //9) Programa una función que obtenga un numero aleatorio entre 501 y 600.
        
        /*
        const aleatorio = () => console.info(Math.round(Math.random() * 100) + 500)

        aleatorio()
        */












        //EJERCICIO 10
        //10) Programa una función que reciba un número y evalúe si es capicúa o no (que se lee igual en un sentido que en otro), 
        //pe. miFuncion(2002) devolverá true.

        /*
        const capicua = (numero = 0) => {
            if(!numero) return console.warn("No ingresaste un número")
            if(typeof numero !== "number") return console.error(`El valor "${numero}" ingresado NO es un número`)
            
            numero = numero.toString()
            let alReves = numero.split("").reverse().join("")

            return (numero === alReves)
                ? console.info(`Si es capicua. Número original ${numero}. Número al revés ${alReves}`)
                : console.info(`NO es capicua. Número original ${numero}. Número al revés ${alReves}`)
        }

        capicua()
        capicua("303")
        capicua(302)
        capicua(303)
        capicua(12.13)
        capicua(12.21)
        */











        //EJERCICIO 11
        //11) Programa una función que calcule el factorial de un número (El factorial de un entero positivo n, 
        //se define como el producto de todos los números enteros positivos desde 1 hasta n), pe. miFuncion(5) devolverá 120.
    
        /*
        const factorial = (numero = undefined) => {
            if (numero === undefined) return console.error("No ingresaste un número")
            if (typeof numero !== "number") return console.error(`El valor "${numero}" ingresado NO es un numero`)
            if (numero === 0) return console.error("El numero no puede ser 0")
            if (Math.sign(numero) === -1) return console.error("El número no puede ser negativo")

            let factorial = 1
            for (let i = numero; i > 1; i--){
                factorial *= i
            }
            return console.log(`El factorial de ${numero} es ${factorial}`)
        }

        factorial()
        factorial("5")
        factorial([1,2,3])
        factorial(0)
        factorial(-5)
        factorial(6)
        */
    











        //EJERCICIO 12
        //12) Programa una función que determine si un número es primo (aquel que solo es divisible por sí mismo y 
        //1) o no, pe. miFuncion(7) devolverá true.

        /*
        const numeroPrimo = (numero = undefined) => {
            if (numero === undefined) return console.error("No ingresaste un número")
            if (typeof numero !== "number") return console.error(`El valor "${numero}" ingresado NO es un numero`)
            if (numero === 0) return console.error("El numero no puede ser 0")
            if (numero === 1) return console.error("El numero no puede ser 1")
            if (Math.sign(numero) === -1) return console.error("El número no puede ser negativo")

            let divisible = false
            for(let i = 2; i < numero; i++){
                if((numero % i) === 0){
                    divisible = true
                    break
                }
            }
            return (divisible)
                ? console.log(`El número ${numero} NO es primo`)
                : console.log(`El número ${numero} SI es primo`)
        }


        numeroPrimo()
        numeroPrimo("320")
        numeroPrimo(true)
        numeroPrimo(0)
        numeroPrimo(1)
        numeroPrimo(-13)
        numeroPrimo(13)
        numeroPrimo(200)
        */












        //EJERCICIO 13
        //13) Programa una función que determine si un número es par o impar, pe. miFuncion(29) devolverá Impar.
    
        /*
        const numeroParImpar = (numero = undefined) => {
            if (numero === undefined) return console.error("No ingresaste un número")
            if (typeof numero !== "number") return console.error(`El valor "${numero}" ingresado NO es un numero`)

            return ((numero % 2) === 0)
                ? console.info(`El numero ${numero} es Par`)
                : console.info(`El numero ${numero} es Impar`)
        }

        numeroParImpar()
        numeroParImpar("23")
        numeroParImpar(-300)
        numeroParImpar(19)
        numeroParImpar(20)
        */















        //EJERCICIO 14
        //14) Programa una función para convertir grados Celsius a Fahrenheit y viceversa, pe. miFuncion(0,"C") devolverá 32°F.

        /*
        const convertirGrados = (grados = undefined, unidad = undefined) => {
            if (grados === undefined) return console.warn("No ingresaste grados a convertir")
            if (typeof grados !== "number") return console.error(`El valor "${grados}"" ingresado NO es un numero`)
            if (unidad === undefined) return console.warn("No ingresaste el tipo de grado a convertir")
            if (typeof unidad !== "string") return console.error(`El valor "${unidad}" ingresado NO es una cadena de texto`)
            if (unidad.length !== 1 || !/(C|F)/.test(unidad)) return console.warn("Valor de unidad no reconocido")
            if(unidad === "C"){
                return console.info(`${grados}ºC = ${Math.round(grados * 9/5 + 32)}ºF`)
            }
            if(unidad === "F"){
                return console.info(`${grados}ºF = ${Math.round((grados -32) * 5/9)}ºC`)
            }
           
        }
        
        convertirGrados()
        convertirGrados("2")
        convertirGrados(2)
        convertirGrados(2,true)
        convertirGrados(2,"Hola")
        convertirGrados(2,"E")
        convertirGrados(3,"C")
        convertirGrados(2,"F")
        */
















        //EJERCICIO 15
        //15) Programa una función para convertir números de base binaria a decimal y 
        //viceversa, pe. miFuncion(100,2) devolverá 4 base 10.

        /*
        const convertirBinarioDecimal = (numero = undefined, base = undefined) => {
            if(numero === undefined) return console.warn("No ingresaste el número a convertir")
            if(typeof numero != "number") return console.error(`El numero ${numero} ingresado, NO es un numero`)
            if(base === undefined) return console.warn("No ingresaste la base a convertir")
            if(typeof base != "number") return console.error(`La base ${base} ingresada NO es un número`)
            
            if(base === 2){
                return console.info(`${numero} base ${base} = ${parseInt(numero,base)} base 10`)
            }else if(base === 10){
                return console.info(`${numero} base ${base} = ${parseInt(numero.toString(2))} base 2`)
            }else
                return console.error("El tipo de base a convertir NO es valido")
        }

        convertirBinarioDecimal()
        convertirBinarioDecimal("3")
        convertirBinarioDecimal(2,"3")
        convertirBinarioDecimal(100,2)
        convertirBinarioDecimal(100110110,2)
        convertirBinarioDecimal(4,10)
        convertirBinarioDecimal(1234,10)
        */















        //EJERCICIO 16
        //16) Programa una función que devuelva el monto final después de aplicar un descuento a una cantidad dada, 
        //pe. miFuncion(1000, 20) devolverá 800.

        /*
        const aplicarDescuento = (monton = undefined, descuento = 0) =>{
            if(monton === undefined) return console.warn("No ingresaste el total")
            if(typeof monton !== "number") return console.error(`El valor "${monton}" ingresado NO es un número`)
            if(monton === 0) return console.error("El montón no puede ser 0")
            if(Math.sign(monton) === -1) return console.error("El montón no puede ser negativo")
            if(typeof descuento != "number") return console.error(`El valor "${descuento}" ingresado NO es un número`)
            if(Math.sign(descuento) === -1) return console.error("El descuento no puede ser negativo")

            return console.info(`${monton} - ${descuento}% = ${monton - ((monton * descuento)/100)}€`)
        }

        aplicarDescuento()
        aplicarDescuento("200")
        aplicarDescuento(0)
        aplicarDescuento(-200)
        aplicarDescuento(1000,"20")
        aplicarDescuento(1000,-20)
        aplicarDescuento(1000)
        aplicarDescuento(1000,25)
        */















        //EJERCICIO 17
        //17) Programa una función que dada una fecha válida determine cuantos años han pasado hasta el día de hoy, 
        //pe. miFuncion(new Date(1984,4,23)) devolverá 35 años (en 2020).

        /*
        const calcularAnios = (fecha = undefined) => {
            if(fecha === undefined) return console.warn("NO ingresaste la fecha")
            if(!(fecha instanceof Date)) return console.error("El valor que ingresaste no es una fecha válida")

            let hoyMenosFecha = new Date().getTime() - fecha.getTime(),
                aniosEnMS = 1000 * 60 * 60 * 24 * 365,
                aniosHumanos = Math.floor(hoyMenosFecha / aniosEnMS)

            return (Math.sign(aniosHumanos) === -1)
                ? console.info(`Faltan ${Math.abs(aniosHumanos)} años para el ${fecha.getFullYear()}.`)
                : (Math.sign(aniosHumanos) === 1)
                    ? console.info(`Han pasado ${aniosHumanos} años desde ${fecha.getFullYear()}.`)
                    : console.info(`Estamos en el año actual ${fecha.getFullYear()}.`)
        }

        calcularAnios()
        calcularAnios({})
        calcularAnios(false)
        calcularAnios(new Date())
        calcularAnios(new Date(1997,2,23))
        calcularAnios(new Date(2080,2,23))
        calcularAnios(new Date(2020,1,5))
        */

    
    
    
    




        








        //EJERCICIO 18
        //18) Programa una función que dada una cadena de texto cuente el número de vocales y consonantes, 
        //pe. miFuncion("Hola Mundo") devuelva Vocales: 4, Consonantes: 5.
    
        /*
        const contarLetras = (cadena ="") => {
            if(!cadena) return console.warn("No ingresaste una cadena de texto")
            if(typeof cadena !== "string") return console.error(`El valor "${cadena}" ingresado NO es una cadena de texto`)

            let vocales = 0,
                consonantes = 0
            
            cadena = cadena.toLocaleLowerCase()

            for(let letra of cadena){
                if(/[aeiouáéíóúü]/.test(letra)) vocales++
                if(/[bcdfghjklmnñpqrstvwxyz]/.test(letra)) consonantes++
            }
            

            return console.info({
                cadena,
                vocales,
                consonantes
            })
        }

        contarLetras()
        contarLetras(3)
        contarLetras("Hola Mundo")
        contarLetras("Ñoño")
        */















        //EJERCICIO 19
        //19) Programa una función que valide que un texto sea un nombre válido, pe. miFuncion("Jonathan MirCha") 
        //devolverá verdadero.

        /*
        const validarNombre = (nombre ="") => {
            if(!nombre) return console.warn("No ingresaste un nombre")
            if(typeof nombre !== "string") return console.error(`El valor ${nombre} ingresado NO es una cadena de texto`)

            //^: no puede haber nada antes
            //$no puede haber nada detrás
            // \s: acepta espacios en blanco
            let expReg = /^[A-Za-zÑñÁáÉéÍíÓóÚúÜü\s]+$/g.test(nombre)
            return (expReg)
                ? console.info(`"${nombre}" es un nombre válido`)
                : console.warn(`"${nombre}" NO es un nombre válido`)
        }

        validarNombre()
        validarNombre(3)
        validarNombre("Rafa Rodríguez")
        validarNombre("Rafa Rodríguez,23")
        */















        //EJERCICIO 20
        //20) Programa una función que valide que un texto sea un email válido, 
        //pe. miFuncion("jonmircha@gmail.com") devolverá verdadero.
        //OJO: esta función no valida dominios, sino la expresión en sí

        /*
        const validarEmail = (email ="") => {
            if(!email) return console.warn("No ingresaste un email")
            if(typeof email !== "string") return console.error(`El valor ${email} ingresado NO es una cadena de texto`)

            // \.: acepta puntos
            // {2,15}: acepta dominios de entre 2 y 15 letras
            let expReg = /[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})/i.test(email)
            return (expReg)
                ? console.info(`"${email}" es un email válido`)
                : console.warn(`"${email}" NO es un email válido`)
        }

        validarEmail()
        validarEmail(34)
        validarEmail("rafa,rodriguez@gmail")
        validarEmail("rafaelrodriguezcalvente@gmail.com")
        */









        //FUSIÓN 19-20

        /*
        const validarPatron = (cadena ="", patron = undefined) => {
            if(!cadena) return console.warn("No ingresaste una cadena a evaluar")
            if(typeof cadena !== "string") return console.error(`El valor ${cadena} ingresado NO es una cadena de texto`)
            if(patron === undefined) return console.warn("No ingresaste un patrón a evaluar")
            if(!(patron instanceof RegExp)) return console.error(`El valor ${patron} ingresado NO es una expresión regular`)

            // \.: acepta puntos
            // {2,15}: acepta dominios de entre 2 y 15 letras
            let expReg = patron.test(cadena)
            return (expReg)
                ? console.info(`"${cadena}" cumple con el patrón ingresado`)
                : console.warn(`"${cadena}" NO cumple con el patrón ingresado`)
        }

        validarPatron()
        validarPatron({})
        validarPatron("Hola Rafa")
        validarPatron("Hola Rafa","Hola")
        validarPatron("Hola Rafa",[1,2,3])
        validarPatron("Rafa Rodríguez",/^[A-Za-zÑñÁáÉéÍíÓóÚúÜü\s]+$/g)
        validarPatron("Rafa Rodríguez,23",/^[A-Za-zÑñÁáÉéÍíÓóÚúÜü\s]+$/g)
        validarPatron("rafaelrodriguezcalvente@gmail.com",/[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})/i)
        validarPatron("rafaelrodriguezcalvente@gmail.m",/[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})/i)
        validarPatron("rafaelrodriguezcalvente@gmail.com",new RegExp("/[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})/","i"))
        validarPatron("rafaelrodriguezcalvente@gmail.m",new RegExp("[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})","i"))
        */







        //EJERCICIO 21
        //21) Programa una función que dado un array numérico devuelve otro array con los números elevados 
        //al cuadrado, pe. mi_funcion([1, 4, 5]) devolverá [1, 16, 25].
    
        //Recordemos que al hacer typeof [] ó typeof {} esto JS nos devuelve "Object" por lo tanto
        //para verificar el tipo de dato usamos instanceof Array p. ej para los vectores   

        /*
        const devolverCuadrados = (arr = undefined) =>{
            if(arr === undefined) return console.warn("NO ingresaste un arreglo de números")
            if(!(arr instanceof Array)) return console.error("El valor que ingresaste no es un arreglo")
            if(arr.length === 0) return console.error("El arreglo está vacío")
            for(let num of arr){
                if(typeof num !== "number") return console.error(`El valor ${num} ingresado NO es un número`)
            }

            //método map MUY UTILIZADO EN ANGULAR, REACT y VUE
            const newArr = arr.map(el => el*el)

            return console.info(`Arreglo original: ${arr}, \n Arreglo elevado al cuadrado: ${newArr}`)
        }

        devolverCuadrados()
        devolverCuadrados(true)
        devolverCuadrados({})
        devolverCuadrados([])
        devolverCuadrados([1,"3",4,{}])
        devolverCuadrados([1,4,{}])
        devolverCuadrados([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])
        */















        //EJERCICIO 22
        //22) Programa una función que dado un array devuelva el número mas alto y el más bajo de dicho 
        //array, pe. miFuncion([1, 4, 5, 99, -60]) devolverá [99, -60].
    
        /*
        const arrayMinMax = (arr = undefined) =>{
            if(arr === undefined) return console.warn("NO ingresaste un arreglo de números")
            if(!(arr instanceof Array)) return console.error("El valor que ingresaste no es un arreglo")
            if(arr.length === 0) return console.error("El arreglo está vacío")
            for(let num of arr){
                if(typeof num !== "number") return console.error(`El valor ${num} ingresado NO es un número`)
            }

            //El método Math.max requiere pasarle el vector con spread operator (...)
            return console.info(`Arreglo original: ${arr}\nValor mayor: ${Math.max(...arr)}\n Valor menor: ${Math.min(...arr)}`)
        }


        arrayMinMax()
        arrayMinMax(false)
        arrayMinMax([])
        arrayMinMax([2,3,true])
        arrayMinMax([1,4,5,99,-60])
        */
    
    
    


    
    



    
    
    
        //EJERCICIO 23
        //23) Programa una función que dado un array de números devuelva un objeto con 2 arreglos en el primero 
        //almacena los números pares y en el segundo los impares, pe. miFuncion([1,2,3,4,5,6,7,8,9,0]) devolverá {pares: [2,4,6,8,0], impares: [1,3,5,7,9]}.
    
        /*
        const separarParesImpares = (arr = undefined) => {
            if(arr === undefined) return console.warn("NO ingresaste un arreglo de números")
            if(!(arr instanceof Array)) return console.error("El valor que ingresaste no es un arreglo")
            if(arr.length === 0) return console.error("El arreglo está vacío")
            for(let num of arr){
                if(typeof num !== "number") return console.error(`El valor ${num} ingresado NO es un número`)
            }

            return console.info({
                //introduce en pares/impares todos los num que cumplan la condicion
                pares:arr.filter(num => num % 2 == 0),
                impares:arr.filter(num => num % 2 === 1)
            })
        }

        separarParesImpares()
        separarParesImpares("hola")
        separarParesImpares([])
        separarParesImpares([2,4,"j"])
        separarParesImpares([1,2,3,4,5,6,7,8,9,0])
        */


    










        //EJERCICIO 24
        //24) Programa una función que dado un arreglo de números devuelva un objeto con dos arreglos, 
        //el primero tendrá los numeros ordenados en forma ascendente y el segundo de forma descendiente, 
        //pe. miFuncion([7, 5,7,8,6]) devolverá { asc: [5,6,7,7,8], desc: [8,7,7,6,5] }.

        /*
        const ordenarArreglo = (arr = undefined) => {
            if(arr === undefined) return console.warn("NO ingresaste un arreglo de números")
            if(!(arr instanceof Array)) return console.error("El valor que ingresaste no es un arreglo")
            if(arr.length === 0) return console.error("El arreglo está vacío")
            for(let num of arr){
                if(typeof num !== "number") return console.error(`El valor ${num} ingresado NO es un número`)
            }

            return console.info({
                arr,
                asc:arr.map(el => el).sort(),
                desc:arr.map(el => el).sort().reverse()
            })
        }

        ordenarArreglo()
        ordenarArreglo("Hola")
        ordenarArreglo([])
        ordenarArreglo([1,2,[]])
        ordenarArreglo([1,2,6,2,3,8,1,45,9,3])
        */











        //EJERCICIO 25
        //25) Programa una función que dado un arreglo de elementos, elimine los duplicados, 
        //pe. miFuncion(["x", 10, "x", 2, "10", 10, true, true]) devolverá ["x", 10, 2, "10", true].
    
        /*
        const quitarDuplicados = (arr = undefined) => {
            if(arr === undefined) return console.warn("NO ingresaste un arreglo de números")
            if(!(arr instanceof Array)) return console.error("El valor que ingresaste no es un arreglo")
            if(arr.length === 0) return console.error("El arreglo está vacío")
            if(arr.length === 1) return console.warn("El arreglo debete tener al menos 2 elementos")

            //return console.info({
            //   original:arr,
            //   //self es el propio arreglo y va comparando sus valores con el arreglo que el método
            //   //filter genera
            //   sinDuplicados:arr.filter((value,index,self) => self.indexOf(value) === index)
            })

            //Otra manera de hacerlo con el método set (nuevo tipo de dato en JS)
            //Este tipo de dato set no permite tener elementos repetidos (por su naturaleza como tipo de dato)

            return console.info({
                original:arr,
                sinDuplicados:[...new Set(arr)]
            })
        }

        quitarDuplicados()
        quitarDuplicados({})
        quitarDuplicados([])
        quitarDuplicados([6])
        quitarDuplicados(["x", 10, "x", 2, "10", 10, true, true])
        */









        //EJERCICIO 26
        //26) Programa una función que dado un arreglo de números obtenga el promedio, 
        //pe. promedio([9,8,7,6,5,4,3,2,1,0]) devolverá 4.5.

        /*
        const promedio = (arr = undefined) => {
            if(arr === undefined) return console.warn("NO ingresaste un arreglo de números")
            if(!(arr instanceof Array)) return console.error("El valor que ingresaste no es un arreglo")
            if(arr.length === 0) return console.error("El arreglo está vacío")
            for(let num of arr){
                if(typeof num !== "number") return console.error(`El valor ${num} ingresado NO es un número`)
            }

            //Los métodos map, filter, reduce generan un nuevo arreglo basado en el arreglo original
            //Un forEach por ejemplo no hace esto, si no que modifica el arreglo que recibe sin crear otro nuevo
            return console.info(
                //total es la variable que funcionará como acumulador, irá guardando el valor previo
                //num es el valor que está recorriendo en cada momento
                //index es la pos que ocupa ese elemento
                arr.reduce((total,num,index,arr) => {
                    total += num
                    if(index === arr.length - 1) return `El promedio de ${arr.join(" + ")} es ${total / arr.length}`
                    else return total
                })
            )
        }

        promedio()
        promedio({})
        promedio([])
        promedio([2,true])
        promedio([9,8,7,6,5,4,3,2,1,0])
        */










        //EJERCICIO 27
        //27) Programa una clase llamada Pelicula.
/*
        La clase recibirá un objeto al momento de instanciarse con los siguentes datos: id de la película en IMDB, 
        titulo, director, año de estreno, país o países de origen, géneros y calificación en IMBD.
        - Todos los datos del objeto son obligatorios.
        - Valida que el id IMDB tenga 9 caracteres, los primeros 2 sean letras y los 7 restantes números.
        - Valida que el título no rebase los 100 caracteres.
        - Valida que el director no rebase los 50 caracteres.
        - Valida que el año de estreno sea un número entero de 4 dígitos.
        - Valida que el país o paises sea introducidos en forma de arreglo.
        - Valida que los géneros sean introducidos en forma de arreglo.
        - Valida que los géneros introducidos esten dentro de los géneros aceptados*.
        - Crea un método estático que devuelva los géneros aceptados*.
        (para saber que géneros se aceptan antes de instanciar un objeto). Se puede hacer por ser estático el método
        - Valida que la calificación sea un número entre 0 y 10 pudiendo ser decimal de una posición.
        - Crea un método que devuelva toda la ficha técnica de la película.
        - Apartir de un arreglo con la información de 3 películas genera 3 
        instancias de la clase de forma automatizada e imprime la ficha técnica de cada película.

        * Géneros Aceptados: Action, Adult, Adventure, Animation, Biography, Comedy, Crime, Documentary ,Drama, 
        Family, Fantasy, Film Noir, Game-Show, History, Horror, Musical, Music, Mystery, News, Reality-TV, 
        Romance, Sci-Fi, Short, Sport, Talk-Show, Thriller, War, Western.
*/


        class Pelicula{
            constructor({id,titulo,director,estreno,pais,generos,calificacion}){
                this.id = id
                this.titulo = titulo
                this.director = director
                this.estreno = estreno
                this.pais = pais
                this.generos = generos
                this.calificacion = calificacion
                //Validaciones
                this.validarIMDB(id)
                this.validarTitulo(titulo)
                this.validarDirector(director)
                this.validarEstreno(estreno)
                this.validarPais(pais)
                this.validarGeneros(generos)
                this.validarCalificacion(calificacion)
            }

            //Recordemos que JS trata a los métodos estáticos como atributos
            static get listaGeneros(){
                return [`Action`, `Adult`, `Adventure`, `Animation`, `Biography`, `Comedy`, `Crime`, `Documentary` ,
                `Drama`, `Family`, `Fantasy`, `Film Noir`, `Game-Show`, `History`,`Horror`, `Musical`, `Music`, `Mystery`, 
                `News`, `Reality-TV`, `Romance`, `Sci-Fi`, `Short`, `Sport`, `Talk-Show`, `Thriller`, `War`, `Western`]
            }
            static generosAceptados(){
                return console.info(`Los géneros aceptados son:\n\n ${Pelicula.listaGeneros.join(", ")}`)
            }
            validarCadena(propiedad,valor){
                if(!valor) return console.warn(`${propiedad} "${valor}" está vacío`)
                if(typeof valor !== "string") return console.error(`${propiedad} "${valor}" ingresado NO es una cadena de texto`)
                return true
            }
            validarLongitudCadena(propiedad,valor,longitud){
                if(valor.length > longitud) return console.error(`${propiedad} "${valor}" excede el número de caracteres permitidos (${longitud}).`)
                return true
            }
            validarNumero(propiedad,valor){
                if(!valor) return console.warn(`${propiedad} "${valor}" está vacío`)
                if(typeof valor!== "number") return console.error(`${propiedad} "${valor}" ingresado NO es un número`)
                return true
            }
            validarArreglo(propiedad,valor){
                if(!valor) return console.warn(`${propiedad} "${valor}" está vacío`)
                if(!(valor instanceof Array)) return console.error(`${propiedad} "${valor}" ingresado NO es un arreglo`)
                if(valor.length === 0) return console.error(`${propiedad} "${valor}" no tiene datos`)
                for(let cadena of valor)
                    if(typeof cadena !== "string") return console.error(`El valor ${cadena} ingresado NO es una cadena de texto`)
                return true
            }
            validarIMDB(id){
                if(this.validarCadena("IMDB id",id)){
                    if(!(/^([a-z]){2}([0-9]){7}$/.test(id)))
                        return console.error(`IMDB ID "${id}" no es válido, debe tener 9 caracteres, las primeras dos son letras minúsculas, los 7 restantes números `)
                }
            }
            validarTitulo(titulo){
                if(this.validarCadena("Título",titulo))
                    this.validarLongitudCadena("Titulo",titulo,100)
            }
            validarDirector(director){
                if(this.validarCadena("Director",director))
                    this.validarLongitudCadena("Director",director,50)
            }
            validarEstreno(estreno){
                if(this.validarNumero("Año de estreno",estreno)){
                    if(!(/^([0-9]){4}$/.test(estreno)))
                        return console.error(`Año de Estreno "${estreno}" no es válido, debe ser un número de 4 dígitos`)
                }
            }
            validarPais(pais){
                this.validarArreglo("País",pais)
            }
            validarGeneros(generos){
                if(this.validarArreglo("Géneros",generos)){
                    for (let genero of generos){
                        //El método includes revisa si una cadena está dentro un arreglo
                        //Recordar que los estáticos no funcionan con this
                        if(!Pelicula.listaGeneros.includes(genero)){
                            console.error(`Género(s) incorrecto(s) "${generos.join(", ")}"`)
                            Pelicula.generosAceptados()
                        }
                    }
                }
            }
            validarCalificacion(calificacion){
                if(this.validarNumero("Calificación",calificacion)){
                    return (calificacion < 0 || calificacion > 10)
                        ? console.error(`La calificación tiene que estar en un rango entre 0 y 10`)
                        //toFixed permite indicar a cuantos numeros queremos acortar el decimal
                        : this.calificacion = calificacion.toFixed(1)
                }
            }
            fichaTecnica(){
                console.info(`Ficha técnica:\n\nTítulo: "${this.titulo}"\nDirector: "${this.director}"\nAño: "${this.estreno}"\nPaís: "${this.pais.join("-")}"\nGéneros: "${this.generos.join(", ")}"\nCalificación: "${this.calificacion}"\nIMDB Id: "${this.id}"\n\n`)
            }
        }
        
        //Comprobación del método estático:
        //Pelicula.generosAceptados()

        //Comprobación validaciones
        //const peli = new Pelicula("tt9898988","Rocky","John G. Avildsen",2020,["España"],["Adventure","Sport","Comedy"],7.78)
        //peli.fichaTecnica()

        const misPelis = [
            {
                id:"tt0758758",
                titulo:"Into the Wild",
                director:"Sean Penn",
                estreno:2007,
                pais:["USA"],
                generos:["Adventure","Biography","Drama"],
                calificacion:8.1
            },
            {
                id: "tt0479143",
                titulo: "Rocky Balboa",
                director: "Sylvester Stallone",
                estreno: 2006,
                pais: ["USA"],
                generos: ["Action","Drama","Sport"],
                calificacion: 7.1
            }
        ]


        misPelis.forEach(el => new Pelicula(el).fichaTecnica())



    </script>
</body>
</html>